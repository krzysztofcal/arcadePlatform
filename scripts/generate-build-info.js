#!/usr/bin/env node
/**
 * Generate build information for the About page.
 * This script runs during Netlify build to capture deployment metadata.
 *
 * Netlify Environment Variables used:
 * - COMMIT_REF: Full git commit SHA
 * - CONTEXT: Build context (production, deploy-preview, branch-deploy, dev)
 * - BRANCH: Git branch name
 * - DEPLOY_ID: Unique Netlify deploy identifier
 * - REVIEW_ID: Pull/Merge request ID (for deploy previews)
 * - REPOSITORY_URL: Git repository URL
 * - HEAD: Branch or PR head reference
 * - PULL_REQUEST: "true" if this is a PR build
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

function getGitCommit() {
  try {
    return execSync('git rev-parse HEAD', { encoding: 'utf8' }).trim();
  } catch {
    return null;
  }
}

function getGitBranch() {
  try {
    return execSync('git rev-parse --abbrev-ref HEAD', { encoding: 'utf8' }).trim();
  } catch {
    return null;
  }
}

function getGitCommitDate() {
  try {
    return execSync('git log -1 --format=%cI', { encoding: 'utf8' }).trim();
  } catch {
    return null;
  }
}

function getBuildType(context) {
  switch (context) {
    case 'production':
      return 'prod';
    case 'deploy-preview':
      return 'preview';
    case 'branch-deploy':
      return 'branch';
    case 'dev':
    case 'development':
      return 'dev';
    default:
      return 'local';
  }
}

function generateBuildInfo() {
  const env = process.env;
  const now = new Date();

  // Netlify provides these, fallback to git commands for local builds
  const commitHash = env.COMMIT_REF || getGitCommit() || 'unknown';
  const commitShort = commitHash.substring(0, 7);
  const branch = env.BRANCH || env.HEAD || getGitBranch() || 'unknown';
  const context = env.CONTEXT || 'local';
  const buildType = getBuildType(context);

  const buildInfo = {
    // Version identification
    version: commitShort,
    commitHash: commitHash,
    commitShort: commitShort,
    commitDate: getGitCommitDate() || null,

    // Build classification
    buildType: buildType,
    context: context,
    isProduction: context === 'production',
    isPreview: context === 'deploy-preview',
    isBranchDeploy: context === 'branch-deploy',
    isLocal: context === 'local',

    // Build metadata
    buildTime: now.toISOString(),
    buildTimestamp: now.getTime(),

    // Branch & PR info
    branch: branch,
    pullRequest: env.PULL_REQUEST === 'true',
    reviewId: env.REVIEW_ID || null,

    // Netlify-specific
    deployId: env.DEPLOY_ID || null,
    deployUrl: env.DEPLOY_PRIME_URL || env.DEPLOY_URL || null,
    siteUrl: env.URL || null,
    siteName: env.SITE_NAME || null,

    // Node version used for build
    nodeVersion: process.version,
  };

  return buildInfo;
}

function main() {
  const buildInfo = generateBuildInfo();

  // Output relative to current working directory (where build runs from)
  const outputDir = path.join(process.cwd(), 'js');
  const outputPath = path.join(outputDir, 'build-info.js');

  // Ensure js/ directory exists
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Create the JS module that exposes build info globally
  const content = `// Auto-generated by scripts/generate-build-info.js
// Do not edit manually - this file is regenerated on each build
window.BUILD_INFO = ${JSON.stringify(buildInfo, null, 2)};
`;

  fs.writeFileSync(outputPath, content, 'utf8');

  console.log('Build info generated:');
  console.log(`  Version: ${buildInfo.commitShort}`);
  console.log(`  Build type: ${buildInfo.buildType}`);
  console.log(`  Context: ${buildInfo.context}`);
  console.log(`  Branch: ${buildInfo.branch}`);
  console.log(`  Build time: ${buildInfo.buildTime}`);
  if (buildInfo.deployId) {
    console.log(`  Deploy ID: ${buildInfo.deployId}`);
  }
  if (buildInfo.reviewId) {
    console.log(`  PR #${buildInfo.reviewId}`);
  }
  console.log(`  Output: ${outputPath}`);
}

main();

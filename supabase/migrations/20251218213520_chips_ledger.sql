-- Chips ledger schema for Supabase
-- Netlify Functions are expected to use the service role key to interact with these tables;
-- RLS policies default to deny until explicit least-privilege policies are introduced.

create extension if not exists "pgcrypto";

create type public.chips_account_type as enum ('USER', 'SYSTEM', 'ESCROW');
create type public.chips_account_status as enum ('active', 'frozen', 'closed');

create table public.chips_accounts (
    id uuid primary key default gen_random_uuid(),
    user_id uuid references auth.users (id),
    account_type public.chips_account_type not null,
    status public.chips_account_status not null default 'active',
    label text,
    balance bigint not null default 0,
    next_entry_seq bigint not null default 1,
    created_at timestamptz not null default timezone('utc', now()),
    updated_at timestamptz not null default timezone('utc', now()),
    constraint chips_accounts_user_unique unique (user_id, account_type),
    constraint chips_accounts_user_balance_non_negative check (account_type <> 'USER' or balance >= 0)
);

create index chips_accounts_user_idx on public.chips_accounts (user_id);
create index chips_accounts_type_idx on public.chips_accounts (account_type);

create table public.chips_transactions (
    id uuid primary key default gen_random_uuid(),
    sequence bigint generated always as identity,
    reference text,
    description text,
    metadata jsonb not null default '{}'::jsonb,
    created_by uuid,
    created_at timestamptz not null default timezone('utc', now()),
    constraint chips_transactions_sequence_positive check (sequence > 0),
    unique (sequence)
);

create table public.chips_entries (
    id bigint generated by default as identity primary key,
    transaction_id uuid not null references public.chips_transactions (id) on delete cascade,
    account_id uuid not null references public.chips_accounts (id),
    entry_seq bigint not null,
    amount bigint not null,
    metadata jsonb not null default '{}'::jsonb,
    created_at timestamptz not null default timezone('utc', now()),
    constraint chips_entries_non_zero_amount check (amount <> 0),
    constraint chips_entries_entry_seq_positive check (entry_seq > 0)
);

create index chips_entries_account_idx on public.chips_entries (account_id);
create index chips_entries_transaction_idx on public.chips_entries (transaction_id);
create unique index chips_entries_account_seq_idx on public.chips_entries (account_id, entry_seq) where entry_seq is not null;

create table if not exists public.chips_account_snapshot (
    id bigint generated by default as identity primary key,
    account_id uuid not null references public.chips_accounts (id) on delete cascade,
    balance bigint not null,
    entry_seq bigint not null,
    as_of timestamptz not null default timezone('utc', now()),
    metadata jsonb not null default '{}'::jsonb,
    unique (account_id, entry_seq)
);

-- Assign per-account entry sequences to enforce monotonic ordering per account
create or replace function public.chips_entries_assign_sequence()
returns trigger
language plpgsql
as $$
declare
    next_seq bigint;
begin
    select next_entry_seq into next_seq from public.chips_accounts where id = new.account_id for update;
    if new.entry_seq is null then
        new.entry_seq := next_seq;
    elsif new.entry_seq <> next_seq then
        raise exception 'Entry sequence must match expected value (%) for account %.', next_seq, new.account_id;
    end if;
    update public.chips_accounts
    set next_entry_seq = next_entry_seq + 1,
        updated_at = timezone('utc', now())
    where id = new.account_id;
    return new;
end;
$$;

create trigger chips_entries_assign_sequence_trg
before insert on public.chips_entries
for each row execute function public.chips_entries_assign_sequence();

-- Apply entry deltas to account balances and enforce non-negative USER balances
create or replace function public.chips_entries_apply_account_delta()
returns trigger
language plpgsql
as $$
begin
    if tg_op = 'INSERT' then
        update public.chips_accounts
        set balance = balance + new.amount,
            updated_at = timezone('utc', now())
        where id = new.account_id;
    elsif tg_op = 'UPDATE' then
        if new.account_id <> old.account_id then
            update public.chips_accounts
            set balance = balance - old.amount,
                updated_at = timezone('utc', now())
            where id = old.account_id;
            update public.chips_accounts
            set balance = balance + new.amount,
                updated_at = timezone('utc', now())
            where id = new.account_id;
        elsif new.amount <> old.amount then
            update public.chips_accounts
            set balance = balance + (new.amount - old.amount),
                updated_at = timezone('utc', now())
            where id = new.account_id;
        end if;
    elsif tg_op = 'DELETE' then
        update public.chips_accounts
        set balance = balance - old.amount,
            updated_at = timezone('utc', now())
        where id = old.account_id;
    end if;
    return coalesce(new, old);
end;
$$;

create trigger chips_entries_apply_account_delta_trg
after insert or update or delete on public.chips_entries
for each row execute function public.chips_entries_apply_account_delta();

create or replace function public.chips_enforce_user_balance_non_negative()
returns trigger
language plpgsql
as $$
begin
    if new.account_type = 'USER' and new.balance < 0 then
        raise exception 'USER account % cannot have negative balance (%).', new.id, new.balance;
    end if;
    return new;
end;
$$;

create constraint trigger chips_accounts_non_negative_user_balance
after insert or update on public.chips_accounts
deferrable initially deferred
for each row execute function public.chips_enforce_user_balance_non_negative();

-- Ensure each transaction remains balanced across entries
create or replace function public.chips_assert_balanced_transaction()
returns trigger
language plpgsql
as $$
declare
    txn_id uuid;
    total bigint;
begin
    txn_id := coalesce(new.transaction_id, old.transaction_id);
    select coalesce(sum(amount), 0) into total from public.chips_entries where transaction_id = txn_id;
    if total <> 0 then
        raise exception 'Chips transaction % is not balanced (net=%).', txn_id, total;
    end if;
    return null;
end;
$$;

create constraint trigger chips_entries_balanced_transaction
after insert or update or delete on public.chips_entries
deferrable initially deferred
for each row execute function public.chips_assert_balanced_transaction();

-- RLS
alter table public.chips_accounts enable row level security;
alter table public.chips_transactions enable row level security;
alter table public.chips_entries enable row level security;
alter table public.chips_account_snapshot enable row level security;

create policy deny_all_chips_accounts on public.chips_accounts
    using (false)
    with check (false);

create policy deny_all_chips_transactions on public.chips_transactions
    using (false)
    with check (false);

create policy deny_all_chips_entries on public.chips_entries
    using (false)
    with check (false);

create policy deny_all_chips_account_snapshot on public.chips_account_snapshot
    using (false)
    with check (false);

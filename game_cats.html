<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Łap koty — Strona gry (Fullscreen FIX)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0b1020; --panel:#0f1430; --border:#1f2550; --muted:#9fb0d0; --accent:#6ee7e7; --accent-2:#a78bfa;
    }
    *{box-sizing:border-box}
    body{margin:0; background:linear-gradient(180deg, #0b1020 0%, #090d19 100%); color:#e8eeff; font-family:Poppins, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;}
    .layout{ display:grid; grid-template-columns: 72px 1fr 280px; gap:14px; padding:14px; min-height:100vh; }
    @media (max-width: 1100px){ .layout{ grid-template-columns: 64px 1fr 220px; } }
    @media (max-width: 860px){ .layout{ grid-template-columns: 56px 1fr; } .right{ display:none; } }
    .left{ background:#111735; border:1px solid var(--border); border-radius:16px; padding:10px; display:flex; flex-direction:column; align-items:center; gap:8px; }
    .icon{ width:36px; height:36px; border-radius:12px; border:1px dashed var(--border); background:transparent; }
    .center{ display:flex; flex-direction:column; gap:12px; }
    .gameWrap{ background:#111735; border:1px solid var(--border); border-radius:16px; padding:12px; position:relative; }
    .gameWrap.fsActive{ border-radius:0; border:none; padding:10px; }
    .stats{ display:grid; grid-template-columns: repeat(5, 1fr); gap:8px; margin-bottom:8px; }
    @media (max-width: 560px){ .stats{ grid-template-columns: repeat(3, 1fr);} }
    @media (max-width: 380px){ .stats{ grid-template-columns: repeat(2, 1fr);} }
    .stat{ background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:10px 12px; display:flex; align-items:center; justify-content:space-between; }
    .controls-row{ display:flex; gap:8px; margin-top:8px;}
    .controls-row button{ flex:1; background:transparent; color:#86e1e1; border:1px solid var(--border); border-radius:10px; padding:10px; }
    canvas#game{ width:100%; height:auto; aspect-ratio:460/320; background:#0b1220; border:1px solid var(--border); border-radius:14px; display:block; touch-action:none; }
    .right{ background:#111735; border:1px solid var(--border); border-radius:16px; padding:12px; display:flex; flex-direction:column; gap:10px; }
    .tile{ height:76px; border-radius:12px; border:1px dashed var(--border); background:transparent; }
    .titleBar{ display:flex; align-items:center; gap:12px; flex-wrap:wrap; }
    .titleBar h1{ margin:0; font-size:20px; }
    .actions{ display:flex; gap:10px; margin-left:auto; }
    .btnIcon{ width:40px; height:40px; border-radius:12px; display:grid; place-items:center; border:1px solid var(--border); background:transparent; color:#cdd6ff; text-decoration:none; }
    .meta{ color:var(--muted); font-size:13px; margin-top:6px; }
    @keyframes pulse { 0%{transform:scale(1)} 25%{transform:scale(1.15)} 100%{transform:scale(1)} }
    .pulse{ animation:pulse 200ms ease-out; }
    .back{ display:inline-flex; align-items:center; gap:8px; text-decoration:none; color:#dfe7ff; border:1px solid var(--border); padding:8px 10px; border-radius:10px; margin-bottom:6px; }

    .fsExitOverlay{ position:absolute; top:12px; right:12px; z-index:5; display:none; }
    .gameWrap.fsActive .fsExitOverlay{ display:block; }
    .fsBtn{ background:rgba(15,20,48,.7); border:1px solid var(--border); color:#fbbf24; border-radius:10px; padding:8px 10px; display:inline-flex; gap:8px; align-items:center; cursor:pointer; }
  </style>
</head>
<body>
  <div class="layout">
    <aside class="left">
      <div class="icon"></div><div class="icon"></div><div class="icon"></div>
      <div class="icon"></div><div class="icon"></div><div class="icon"></div>
      <div class="icon"></div>
    </aside>

    <section class="center">
      <a class="back" href="index.html">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M15 18l-6-6 6-6" stroke="#86e1e1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        Wróć do portalu
      </a>

      <div class="gameWrap" id="gameWrap">
        <div class="fsExitOverlay">
          <button id="overlayExit" class="fsBtn" title="Exit full screen">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M9 9H4V4m11 0h5v5M9 15H4v5m11 0h5v-5" stroke="#fbbf24" stroke-width="2" stroke-linecap="round"/></svg>
            Exit full screen
          </button>
        </div>

        <div class="stats">
          <div class="stat"><span>Żetony</span><strong id="tokens">-</strong></div>
          <div class="stat"><span>Czas</span><strong id="timeLeft">-</strong></div>
          <div class="stat"><span>Poziom</span><strong id="level">-</strong></div>
          <div class="stat"><span>Ostatni</span><strong id="lastScore">-</strong></div>
          <div class="stat"><span>Rekord</span><strong id="highScore">-</strong></div>
        </div>

        <div class="controls-row" style="margin-bottom:8px;">
          <button id="playBtn">Zagraj (−1 żeton)</button>
          <button id="buyBtn">Kup żetony (+10)</button>
          <button id="resetBtn">Reset</button>
        </div>

        <canvas id="game"></canvas>

        <div class="controls-row">
          <button id="leftBtn">← Lewo</button>
          <button id="rightBtn">Prawo →</button>
        </div>

        <div style="margin-top:6px;"><span id="status" style="color:#9fb0d0;" aria-live="polite"></span></div>
      </div>

      <div class="titleBar">
        <h1>Łap koty — Arcade</h1>
        <div class="actions">
          <button type="button" class="btnIcon" aria-label="Like">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M12 21s-7-4.35-7-10a4 4 0 0 1 7-2.65A4 4 0 0 1 19 11c0 5.65-7 10-7 10z" stroke="#a78bfa" stroke-width="2"/></svg>
          </button>
          <button type="button" class="btnIcon" aria-label="Share">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M4 12v7a1 1 0 0 0 1 1h14a1 1 0 0 0 1-1v-7M16 6l-4-4-4 4M12 2v14" stroke="#6ee7e7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </button>
          <button type="button" class="btnIcon" id="btnEnterFs" title="Full screen" aria-label="Full screen">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M8 3H3v5M16 3h5v5M8 21H3v-5M21 21h-5v-5" stroke="#9fb0d0" stroke-width="2" stroke-linecap="round"/></svg>
          </button>
          <button type="button" class="btnIcon" id="btnExitFs" title="Exit full screen" aria-label="Exit full screen" style="display:none;">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M9 9H4V4m11 0h5v5M9 15H4v5m11 0h5v-5" stroke="#fbbf24" stroke-width="2" stroke-linecap="round"/></svg>
          </button>
        </div>
      </div>
      <div class="meta">Pełny ekran wykorzystuje Fullscreen API. Użyj przycisku w pasku lub żółtego przycisku w prawym górnym rogu w trybie pełnego ekranu. Esc też działa.</div>
    </section>

    <aside class="right">
      <div class="tile"></div><div class="tile"></div><div class="tile"></div>
      <div class="tile"></div><div class="tile"></div><div class="tile"></div>
      <div class="tile"></div><div class="tile"></div>
    </aside>
  </div>

  <script>
    // === Fullscreen controls ===
    const gameWrap = document.getElementById('gameWrap');
    const btnEnterFs = document.getElementById('btnEnterFs');
    const btnExitFs = document.getElementById('btnExitFs');
    const overlayExit = document.getElementById('overlayExit');
    const canvas = document.getElementById('game');

    function isFullscreenActive(){
      return document.fullscreenElement === gameWrap || document.webkitFullscreenElement === gameWrap;
    }
    function enterFullscreen() {
      if (gameWrap.requestFullscreen) gameWrap.requestFullscreen();
      else if (gameWrap.webkitRequestFullscreen) gameWrap.webkitRequestFullscreen();
    }
    function exitFullscreen() {
      if (document.exitFullscreen) document.exitFullscreen();
      else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
    }
    btnEnterFs.addEventListener('click', (e)=>{ e.preventDefault(); enterFullscreen(); });
    btnExitFs.addEventListener('click', (e)=>{ e.preventDefault(); exitFullscreen(); });
    overlayExit.addEventListener('click', (e)=>{ e.preventDefault(); exitFullscreen(); });

    function syncFsButtons() {
      const isFs = isFullscreenActive();
      btnEnterFs.style.display = isFs ? 'none' : '';
      btnExitFs.style.display = isFs ? '' : 'none';
      gameWrap.classList.toggle('fsActive', isFs);
      fitCanvasToViewport();
    }
    document.addEventListener('fullscreenchange', syncFsButtons);
    document.addEventListener('webkitfullscreenchange', syncFsButtons);

    // Fit canvas to viewport in fullscreen so paddle/controls are visible
    function fitCanvasToViewport(){
      if (!isFullscreenActive()) {
        canvas.style.width = '100%';
        requestAnimationFrame(resizeCanvas);
        return;
      }
      const aspect = 460/320; // width / height
      const wrapRect = gameWrap.getBoundingClientRect();
      const reserved = 200; // px -> approx. stats + controls + margins
      const maxW = wrapRect.width - 20;
      const maxHforCanvas = Math.max(200, (window.innerHeight - reserved));
      const fitWidth = Math.min(maxW, Math.floor(maxHforCanvas * aspect));
      canvas.style.width = fitWidth + 'px';
      requestAnimationFrame(resizeCanvas);
    }
    window.addEventListener('resize', ()=>{ fitCanvasToViewport(); });

    // === Game (smooth time cats) ===
    const DEFAULT_STATE = { tokens: 10, lastScore: 0, highScore: 0 };
    const KEY = "arcade_cats_smooth_state_page_fs_fix";
    function loadState(){ try { return { ...DEFAULT_STATE, ...JSON.parse(localStorage.getItem(KEY) || "{}") }; } catch { return { ...DEFAULT_STATE }; } }
    function saveState(s){ localStorage.setItem(KEY, JSON.stringify(s)); }
    let state = loadState();

    const tokensEl = document.getElementById("tokens");
    const timeLeftEl = document.getElementById("timeLeft");
    const levelEl = document.getElementById("level");
    const lastScoreEl = document.getElementById("lastScore");
    const highScoreEl = document.getElementById("highScore");
    const playBtn = document.getElementById("playBtn");
    const buyBtn = document.getElementById("buyBtn");
    const resetBtn = document.getElementById("resetBtn");
    const statusEl = document.getElementById("status");
    const leftBtn = document.getElementById("leftBtn");
    const rightBtn = document.getElementById("rightBtn");
    const ctx = canvas.getContext("2d");

    let audioCtx=null;
    function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
    function meow(){ ensureAudio(); const now=audioCtx.currentTime; const o=audioCtx.createOscillator(), g=audioCtx.createGain();
      o.type="triangle"; o.frequency.setValueAtTime(300, now); o.frequency.exponentialRampToValueAtTime(220, now+0.12);
      g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.3, now+0.02); g.gain.exponentialRampToValueAtTime(0.0001, now+0.22);
      o.connect(g).connect(audioCtx.destination); o.start(now); o.stop(now+0.25); }
    function hiss(){ ensureAudio(); const now=audioCtx.currentTime; const len=2*audioCtx.sampleRate*0.2; const buf=audioCtx.createBuffer(1,len,audioCtx.sampleRate);
      const data=buf.getChannelData(0); for(let i=0;i<len;i++) data[i]=(Math.random()*2-1)*0.6;
      const src=audioCtx.createBufferSource(); src.buffer=buf; const filter=audioCtx.createBiquadFilter(); filter.type="highpass"; filter.frequency.value=2000;
      const g=audioCtx.createGain(); g.gain.value=0.2; src.connect(filter).connect(g).connect(audioCtx.destination); src.start(now); src.stop(now+0.2); }

    let running=false, score=0, msLeft=15000, level=1;
    let paddle={x:0, w:110, h:14, speed:6, left:false, right:false};
    let cats=[], spawnCooldown=0, effects=[];

    function resizeCanvas(){
      const rect = canvas.getBoundingClientRect();
      const prevW = rect.width || 1;
      const relX = (paddle && prevW) ? (paddle.x / prevW) : 0.5;
      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = rect.width * (320/460) * window.devicePixelRatio;
      const newW = canvas.getBoundingClientRect().width || prevW;
      paddle.x = Math.max(0, Math.min(newW - paddle.w, (isFinite(relX) ? relX : 0.5) * newW));
      ctx.setTransform(1,0,0,1,0,0);
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    }
    new ResizeObserver(()=>{ requestAnimationFrame(resizeCanvas); }).observe(canvas);
    window.addEventListener('resize', ()=>requestAnimationFrame(resizeCanvas));
    document.addEventListener('fullscreenchange', ()=>requestAnimationFrame(resizeCanvas));
    document.addEventListener('webkitfullscreenchange', ()=>requestAnimationFrame(resizeCanvas));
    resizeCanvas();
    const canvasWidth = () => canvas.getBoundingClientRect().width;
    const canvasHeight = () => canvas.getBoundingClientRect().width * (320/460);

    const currentLevel = () => 1 + Math.floor(score / 5);
    function levelParams(lv){ const fallBase=2.2+lv*0.6; const maxCats=lv>=6?3:(lv>=3?2:1); const spawnEvery=Math.max(14, 40-lv*4); return {fallBase,maxCats,spawnEvery}; }
    const fmtTime = (ms)=> (Math.max(0, ms)/1000).toFixed(1)+"s";
    function renderHud(){ tokensEl.textContent=state.tokens; timeLeftEl.textContent=fmtTime(msLeft); lastScoreEl.textContent=state.lastScore; highScoreEl.textContent=state.highScore; levelEl.textContent=level; playBtn.disabled=state.tokens<=0||running; statusEl.textContent=running?("Punkty: "+score):"Gotowy"; }
    function spawnCat(){ const {fallBase}=levelParams(level); cats.push({x:Math.random()*(canvasWidth()-22)+11, y:-16, r:11, vy:fallBase+Math.random()*2}); }
    function pushEffect(x,y,text,color){ effects.push({x,y,text,color,vy:-0.6,life:60}); }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const H=canvasHeight();
      ctx.fillStyle="#60a5fa"; ctx.fillRect(paddle.x,H-24,paddle.w,paddle.h);
      for(const c of cats){ ctx.beginPath(); ctx.arc(c.x,c.y,c.r+3,0,Math.PI*2); ctx.fillStyle="#1f2937"; ctx.fill();
        ctx.beginPath(); ctx.arc(c.x,c.y,c.r,0,Math.PI*2); ctx.fillStyle="#fbbf24"; ctx.fill();
        ctx.font="16px system-ui, 'Apple Color Emoji', 'Segoe UI Emoji'"; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillStyle="#0b1220"; ctx.fillText("🐱", c.x, c.y+1); }
      for(const e of effects){ ctx.globalAlpha=Math.max(0,e.life/60); ctx.font="bold 16px system-ui"; ctx.textAlign="center"; ctx.fillStyle=e.color; ctx.fillText(e.text,e.x,e.y); ctx.globalAlpha=1; }
      ctx.fillStyle="#9fb0d0"; ctx.font="12px system-ui"; ctx.fillText(running?"Łap koty! ← → / dotknij":"Naciśnij Zagraj",10,18);
    }
    function endGame(){ running=false; state.lastScore=score; if(score>state.highScore) state.highScore=score; saveState(state); renderHud(); }
    function update(dt){
      if(!running) return;
      const W=canvasWidth(), H=canvasHeight();
      msLeft -= dt; if(msLeft<=0){ msLeft=0; endGame(); return; }
      const newLevel=currentLevel(); if(newLevel!==level) level=newLevel;
      const {maxCats,spawnEvery}=levelParams(level);
      if(paddle.left) paddle.x -= paddle.speed; if(paddle.right) paddle.x += paddle.speed;
      paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));
      spawnCooldown -= 1; if(spawnCooldown<=0 && cats.length<maxCats){ spawnCat(); spawnCooldown=spawnEvery; }
      for(let i=cats.length-1;i>=0;i--){
        const c=cats[i]; c.y+=c.vy;
        const withinX=(c.x+c.r)>=paddle.x && (c.x-c.r)<=paddle.x+paddle.w;
        const withinY=(c.y+c.r)>=(H-24) && (c.y-c.r)<=(H-24+paddle.h);
        if(withinX && withinY){ score+=1; msLeft+=1000; timeLeftEl.classList.remove("pulse"); void timeLeftEl.offsetWidth; timeLeftEl.classList.add("pulse");
          pushEffect(c.x, Math.max(20,c.y-8), "+1", "#facc15"); meow(); cats.splice(i,1); continue; }
        if(c.y-c.r>H){ msLeft=Math.max(0, msLeft-1000); timeLeftEl.classList.remove("pulse"); void timeLeftEl.offsetWidth; timeLeftEl.classList.add("pulse");
          pushEffect(c.x, H-30, "-1", "#f87171"); hiss(); cats.splice(i,1); if(msLeft<=0){ endGame(); return; } }
      }
      for(let i=effects.length-1;i>=0;i--){ const e=effects[i]; e.y+=e.vy; e.life-=1; if(e.life<=0) effects.splice(i,1); }
      renderHud();
    }
    let last=0; function loop(ts){ if(!last) last=ts; const dt=ts-last; last=ts; update(dt); draw(); requestAnimationFrame(loop); }
    requestAnimationFrame(loop);

    function startGame(){ if(running||state.tokens<=0) return; ensureAudio(); state.tokens-=1; saveState(state); running=true; score=0; level=1; cats=[]; spawnCooldown=0; msLeft=15000; renderHud(); }
    const buy=()=>{ if(running) return; state.tokens+=10; saveState(state); renderHud(); };
    const resetDemo=()=>{ if(running) return; state={...DEFAULT_STATE}; saveState(state); renderHud(); };

    window.addEventListener('keydown', e=>{ if(e.key==='ArrowLeft') paddle.left=true; if(e.key==='ArrowRight') paddle.right=true; });
    window.addEventListener('keyup', e=>{ if(e.key==='ArrowLeft') paddle.left=false; if(e.key==='ArrowRight') paddle.right=false; });
    function clientToCanvasX(clientX){ const r=canvas.getBoundingClientRect(); return (clientX-r.left); }
    function setPaddleByPointerX(clientX){ const cx=clientToCanvasX(clientX); paddle.x=Math.max(0, Math.min(canvasWidth()-paddle.w, cx-paddle.w/2)); }
    canvas.addEventListener('pointerdown', e=>{ setPaddleByPointerX(e.clientX); e.preventDefault(); }, {passive:false});
    canvas.addEventListener('pointermove', e=>{ if(e.buttons) setPaddleByPointerX(e.clientX); e.preventDefault(); }, {passive:false});

    let btnInterval=null;
    function pressDir(dir){ if(btnInterval) clearInterval(btnInterval); if(dir==='left'){ paddle.left=true; paddle.right=false; } if(dir==='right'){ paddle.right=true; paddle.left=false; } btnInterval=setInterval(()=>{},50); }
    function releaseDir(){ if(btnInterval) clearInterval(btnInterval); paddle.left=false; paddle.right=false; }
    document.getElementById('leftBtn').addEventListener('pointerdown',()=>pressDir('left'));
    document.getElementById('rightBtn').addEventListener('pointerdown',()=>pressDir('right'));
    document.getElementById('leftBtn').addEventListener('pointerup',releaseDir);
    document.getElementById('rightBtn').addEventListener('pointerup',releaseDir);
    document.getElementById('leftBtn').addEventListener('pointerleave',releaseDir);
    document.getElementById('rightBtn').addEventListener('pointerleave',releaseDir);

    playBtn.addEventListener('click', startGame);
    buyBtn.addEventListener('click', buy);
    resetBtn.addEventListener('click', resetDemo);

    (function(){ syncFsButtons(); renderHud(); draw(); })();
  </script>
</body>
</html>


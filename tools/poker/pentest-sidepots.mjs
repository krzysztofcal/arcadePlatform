#!/usr/bin/env node
import assert from "node:assert/strict";
import crypto from "node:crypto";

import {
  deriveDeck,
  deriveCommunityCards,
  deriveRemainingDeck,
} from "../../netlify/functions/_shared/poker-deal-deterministic.mjs";

import { dealHoleCards } from "../../netlify/functions/_shared/poker-engine.mjs";
import { applyAction, advanceIfNeeded } from "../../netlify/functions/_shared/poker-reducer.mjs";
import { isStateStorageValid, withoutPrivateState } from "../../netlify/functions/_shared/poker-state-utils.mjs";

const USERS = ["u1", "u2", "u3"];
const TABLE_ID = "local-sidepot-test";
const now = () => Date.now();
const uuid = () => crypto.randomUUID();

function sum(obj) {
  return Object.values(obj || {}).reduce((a, b) => a + Number(b || 0), 0);
}

function isStateLike(x) {
  return (
    x &&
    typeof x === "object" &&
    typeof x.phase === "string" &&
    Array.isArray(x.seats) &&
    x.stacks &&
    typeof x.stacks === "object"
  );
}

function extractState(x) {
  if (!x) return x;
  if (isStateLike(x)) return x;

  if (x && typeof x === "object") {
    const candidates = [x.state, x.nextState, x.gameState, x.result, x.data, x.value];
    for (const c of candidates) {
      if (isStateLike(c)) return c;
      if (c && typeof c === "object" && isStateLike(c.state)) return c.state;
    }

    if (Array.isArray(x)) {
      for (const el of x) {
        const found = extractState(el);
        if (isStateLike(found)) return found;
      }
    }

    for (const v of Object.values(x)) {
      if (isStateLike(v)) return v;
      if (v && typeof v === "object" && isStateLike(v.state)) return v.state;
    }
  }

  return x;
}

function snapshotPublic(label, state) {
  const real = extractState(state);
  const s = withoutPrivateState(real);
  console.log(`\n=== ${label} ===`);
  console.log({
    phase: s.phase,
    pot: s.pot,
    stacks: s.stacks,
    contributionsByUserId: s.contributionsByUserId,
    sidePots: s.sidePots ?? null,
    foldedByUserId: s.foldedByUserId,
    handId: s.handId,
    communityDealt: s.communityDealt,
    communityLen: Array.isArray(s.community) ? s.community.length : null,
    turnUserId: s.turnUserId,
  });
}

function debugPrivate(label, state) {
  const real = extractState(state);
  const deckLen = Array.isArray(real.deck) ? real.deck.length : null;
  const holeKeys =
    real.holeCardsByUserId && typeof real.holeCardsByUserId === "object"
      ? Object.keys(real.holeCardsByUserId)
      : null;
  const holeOk = holeKeys ? USERS.every((u) => Array.isArray(real.holeCardsByUserId[u])) : false;

  console.log(`\n--- DEBUG PRIVATE: ${label} ---`);
  console.log({
    handSeedType: typeof real.handSeed,
    handSeedPresent: Boolean(real.handSeed && String(real.handSeed).trim()),
    deckIsArray: Array.isArray(real.deck),
    deckLen,
    holeCardsType: typeof real.holeCardsByUserId,
    holeKeys,
    holeOk,
    communityDealt: real.communityDealt,
    communityLen: Array.isArray(real.community) ? real.community.length : null,
  });
}

function attachCommunity(state) {
  const desired = Number(state.communityDealt) || 0;
  const curLen = Array.isArray(state.community) ? state.community.length : 0;
  if (desired <= curLen) return state;

  return {
    ...state,
    community: deriveCommunityCards({
      handSeed: state.handSeed,
      seatUserIdsInOrder: USERS,
      communityDealt: desired,
    }),
  };
}

function attachPrivateFromSeed(state) {
  const handSeed = state.handSeed;
  assert.ok(typeof handSeed === "string" && handSeed.trim(), "handSeed missing on state");

  const communityDealt = Number(state.communityDealt) || 0;

  const deck = deriveRemainingDeck({
    handSeed,
    seatUserIdsInOrder: USERS,
    communityDealt,
  });

  const dealt = dealHoleCards(deriveDeck(handSeed), USERS);

  let next = {
    ...state,
    deck,
    holeCardsByUserId: dealt.holeCardsByUserId,
  };

  next = attachCommunity(next);
  return next;
}

function buildInitialState() {
  const handSeed = `seed-${uuid()}`;
  const handId = `hand-${uuid()}`;

  const stacks = { u1: 20, u2: 50, u3: 200 };

  const base = {
    tableId: TABLE_ID,
    phase: "PREFLOP",
    seats: USERS.map((u, i) => ({ userId: u, seatNo: i + 1 })),

    stacks,
    pot: 0,
    community: [],
    communityDealt: 0,

    dealerSeatNo: 1,
    turnUserId: "u2",

    handId,
    handSeed,

    toCallByUserId: Object.fromEntries(USERS.map((u) => [u, 0])),
    betThisRoundByUserId: Object.fromEntries(USERS.map((u) => [u, 0])),
    actedThisRoundByUserId: Object.fromEntries(USERS.map((u) => [u, false])),
    foldedByUserId: Object.fromEntries(USERS.map((u) => [u, false])),

    contributionsByUserId: Object.fromEntries(USERS.map((u) => [u, 0])),
    allInByUserId: Object.fromEntries(USERS.map((u) => [u, false])),

    lastAggressorUserId: null,
    lastActionRequestIdByUserId: {},

    sidePots: null,
    showdown: null,

    turnNo: 1,
    turnStartedAt: now(),
    turnDeadlineAt: now() + 15000,
  };

  const state = attachPrivateFromSeed(base);
  return { state, initialTotal: sum(stacks) };
}

function forceAllInLike(state, userId) {
  const stack = Number(state.stacks?.[userId]) || 0;
  if (stack <= 0) return null;

  const toCall = Number(state.toCallByUserId?.[userId]) || 0;
  if (toCall > 0) return { type: "CALL" };

  return { type: "BET", amount: stack };
}

function applyAndAdvanceOnce(state, action, userId) {
  const appliedRaw = applyAction(state, { ...action, userId });
  let next = extractState(appliedRaw);

  if (!isStateLike(next)) {
    const keys = appliedRaw && typeof appliedRaw === "object" ? Object.keys(appliedRaw) : null;
    throw new Error(`applyAction did not return state-like object; keys=${JSON.stringify(keys)}`);
  }

  if (typeof next.handSeed !== "string" || !next.handSeed.trim()) {
    next = { ...next, handSeed: state.handSeed };
  }

  if (!Array.isArray(next.deck) || !next.holeCardsByUserId) {
    next = attachPrivateFromSeed(next);
  } else {
    next = attachCommunity(next);
  }

  const advRaw = advanceIfNeeded({ tableId: TABLE_ID, state: next, nowMs: now() });
  const advanced = extractState(advRaw);
  if (advanced && isStateLike(advanced)) next = advanced;

  if (typeof next.handSeed !== "string" || !next.handSeed.trim()) {
    next = { ...next, handSeed: state.handSeed };
  }

  if (!Array.isArray(next.deck) || !next.holeCardsByUserId) {
    next = attachPrivateFromSeed(next);
  } else {
    next = attachCommunity(next);
  }

  return next;
}

/**
 * Key fix:
 * If turnUserId is null (everyone all-in / no actor),
 * keep ticking advanceIfNeeded until we either:
 * - get a turnUserId again, or
 * - reach SHOWDOWN/HAND_DONE, or
 * - no further state changes.
 */
function autoAdvanceUntilActOrDone(state) {
  let s = state;

  for (let i = 0; i < 25; i++) {
    if (s.phase === "SHOWDOWN" || s.phase === "HAND_DONE") return s;
    if (s.turnUserId) return s;

    const advRaw = advanceIfNeeded({ tableId: TABLE_ID, state: s, nowMs: now() });
    const next = extractState(advRaw);

    // advanceIfNeeded might return wrapper or even undefined if no-op
    const nextState = (next && isStateLike(next)) ? next : s;

    // ensure private + community are consistent after advancing
    let fixed = nextState;
    if (typeof fixed.handSeed !== "string" || !fixed.handSeed.trim()) {
      fixed = { ...fixed, handSeed: s.handSeed };
    }
    if (!Array.isArray(fixed.deck) || !fixed.holeCardsByUserId) {
      fixed = attachPrivateFromSeed(fixed);
    } else {
      fixed = attachCommunity(fixed);
    }

    // break if nothing changed (avoid infinite loop)
    const samePhase = fixed.phase === s.phase;
    const sameTurn = fixed.turnUserId === s.turnUserId;
    const sameDealt = Number(fixed.communityDealt) === Number(s.communityDealt);
    if (samePhase && sameTurn && sameDealt) return fixed;

    s = fixed;
  }

  return s;
}

async function main() {
  console.log("[sidepots] POKER_DEAL_SECRET present:", Boolean(process.env.POKER_DEAL_SECRET?.trim()));
  assert.ok(process.env.POKER_DEAL_SECRET?.trim(), "POKER_DEAL_SECRET missing");

  const { state: initial, initialTotal } = buildInitialState();
  let state = initial;

  snapshotPublic("START", state);
  debugPrivate("START", state);

  const okPublic = isStateStorageValid(state, { requirePrivate: false });
  const okPrivate = isStateStorageValid(state, { requirePrivate: true });
  console.log("\n[sidepots] isStateStorageValid:", {
    requirePrivate_false: okPublic,
    requirePrivate_true: okPrivate,
  });

  assert.ok(okPrivate, "invalid state");

  for (let step = 1; step <= 120; step++) {
    // If no one can act, auto-advance phases/board
    state = autoAdvanceUntilActOrDone(state);

    if (state.phase === "SHOWDOWN" || state.phase === "HAND_DONE") break;

    // If nobody has the turn, the engine should auto-advance (all-in / no-action spot).
if (!state.turnUserId) {
  const before = state;
  state = autoAdvanceUntilActOrDone(state);

  // If still no turn and not terminal => engine is stuck (real bug).
  if (!state.turnUserId && state.phase !== "SHOWDOWN" && state.phase !== "HAND_DONE") {
    snapshotPublic("STUCK_STATE", state);
    throw new Error(
      `engine_stuck: turnUserId=null in phase=${state.phase} (expected auto-advance to showdown)`
    );
  }

  // If we reached terminal phase, break; otherwise continue and use the new turnUserId.
  if (state.phase === "SHOWDOWN" || state.phase === "HAND_DONE") break;
}

// Now safe: there is a turn user
const u = state.turnUserId;

    const action = forceAllInLike(state, u);
    if (!action) {
      // Player has no stack; engine might still need auto-advance
      state = autoAdvanceUntilActOrDone(state);
      continue;
    }

    try {
      state = applyAndAdvanceOnce(state, action, u);
    } catch (e) {
      snapshotPublic(`FAIL STEP ${step}`, state);
      debugPrivate(`FAIL STEP ${step}`, state);
      throw e;
    }

    state = autoAdvanceUntilActOrDone(state);

    const ok = isStateStorageValid(state, { requirePrivate: true });
    if (!ok) {
      snapshotPublic(`FAIL STEP ${step}`, state);
      debugPrivate(`FAIL STEP ${step}`, state);
      throw new Error("invalid state");
    }

    const stacksSum = sum(state.stacks);
    const contribSum = sum(state.contributionsByUserId);
    const pot = Number(state.pot) || 0;

    assert.equal(contribSum, pot, "pot != contributions sum");
    assert.equal(stacksSum + pot, initialTotal, "money not conserved");
    for (const v of USERS) assert.ok((Number(state.stacks?.[v]) || 0) >= 0, `negative stack for ${v}`);

    if (step <= 20) snapshotPublic(`STEP ${step}: ${u} ${action.type}`, state);
  }

  snapshotPublic("FINAL", state);

  // Not all engines materialize sidePots into state; some only compute it at payout time.
  // So we DON'T assert sidePots != null here. We only assert money conservation + validity.
  console.log("\n[sidepots] âœ… side pot scenario completed (state valid + money conserved)");
}

main().catch((e) => {
  console.error("[sidepots] fatal:", e);
  process.exit(1);
});

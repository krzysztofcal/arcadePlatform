#!/usr/bin/env node
import assert from "node:assert/strict";
import crypto from "node:crypto";

import {
  deriveDeck,
  deriveCommunityCards,
  deriveRemainingDeck,
} from "../../netlify/functions/_shared/poker-deal-deterministic.mjs";

import { dealHoleCards } from "../../netlify/functions/_shared/poker-engine.mjs";

import {
  applyAction,
  advanceIfNeeded,
} from "../../netlify/functions/_shared/poker-reducer.mjs";

import {
  isStateStorageValid,
  withoutPrivateState,
} from "../../netlify/functions/_shared/poker-state-utils.mjs";

const now = () => Date.now();

const TABLE_ID = "local-money-test";
const USERS = ["u1", "u2", "u3"];

const randInt = (min, max) =>
  min + Math.floor(Math.random() * (max - min + 1));

const uuid = () => crypto.randomUUID();

/* ----------------------------- helpers ----------------------------- */

function sumStacks(stacks) {
  return USERS.reduce((acc, u) => acc + (Number(stacks?.[u]) || 0), 0);
}

function snapshot(label, state) {
  const pub = withoutPrivateState(state);
  console.log(`\n=== ${label} ===`);
  console.log({
    phase: pub.phase,
    handId: pub.handId,
    dealerSeatNo: pub.dealerSeatNo,
    turnUserId: pub.turnUserId,
    pot: pub.pot,
    communityDealt: pub.communityDealt,
    communityLen: Array.isArray(pub.community) ? pub.community.length : null,
    stacks: pub.stacks,
    toCallByUserId: pub.toCallByUserId,
    betThisRoundByUserId: pub.betThisRoundByUserId,
    contributionsByUserId: pub.contributionsByUserId,
    foldedByUserId: pub.foldedByUserId,
    lastAggressorUserId: pub.lastAggressorUserId ?? null,
  });
}

function assertMoneyInvariants(state, initialTotal) {
  const pot = Number(state.pot) || 0;
  assert.ok(pot >= 0, "pot < 0");

  for (const u of USERS) {
    const s = Number(state.stacks?.[u]);
    assert.ok(Number.isFinite(s), `stack ${u} not finite`);
    assert.ok(s >= 0, `stack ${u} < 0`);
  }

  const total = pot + sumStacks(state.stacks);
  assert.equal(
    total,
    initialTotal,
    `money conservation failed: ${total} !== ${initialTotal}`
  );

  if (state.contributionsByUserId) {
    const contribSum = USERS.reduce(
      (a, u) => a + (Number(state.contributionsByUserId?.[u]) || 0),
      0
    );
    assert.equal(
      contribSum,
      pot,
      `contributions (${contribSum}) != pot (${pot})`
    );
  }
}

function chooseLegalAction(state, userId) {
  const toCall = Number(state.toCallByUserId?.[userId]) || 0;
  const stack = Number(state.stacks?.[userId]) || 0;
  const currentBet = Number(state.betThisRoundByUserId?.[userId]) || 0;

  if (stack <= 0) return { type: "CHECK" };

  if (toCall > 0) {
    const r = Math.random();
    if (r < 0.15) return { type: "FOLD" };
    if (r < 0.85) return { type: "CALL" };

    const min = toCall + 1;
    const max = stack + currentBet;
    if (max < min) return { type: "CALL" };

    return { type: "RAISE", amount: randInt(min, max) };
  }

  if (Math.random() < 0.7) return { type: "CHECK" };
  return { type: "BET", amount: randInt(1, stack) };
}

/* ------------------------ reducer integration ----------------------- */

function applyAndAdvance(state, privateState, userId, action) {
  // applyAction in THIS repo returns { state, events }
  const applied = applyAction({
    tableId: TABLE_ID,
    state,
    userId,
    action,
    requestId: `req-${uuid()}`,
    nowMs: now(),
  });

  let next = applied.state;

  // reattach private state ONLY
  next = { ...next, ...privateState };

  const adv = advanceIfNeeded({
    tableId: TABLE_ID,
    state: next,
    nowMs: now(),
  });

  if (adv?.state) {
    next = { ...adv.state, ...privateState };
  }

  // deal community deterministically
  const want = Number(next.communityDealt) || 0;
  const have = Array.isArray(next.community) ? next.community.length : 0;

  if (want > have) {
    next = {
      ...next,
      community: deriveCommunityCards({
        handSeed: next.handSeed,
        seatUserIdsInOrder: USERS,
        communityDealt: want,
      }),
    };
  }

  return next;
}

/* -------------------------- initial state ---------------------------- */

function buildInitialState() {
  const handSeed = `seed-${uuid()}`;
  const handId = `hand-${uuid()}`;

  const stacks = { u1: 50, u2: 100, u3: 200 };
  const initialTotal = sumStacks(stacks);

  const base = {
    tableId: TABLE_ID,
    phase: "PREFLOP",
    seats: USERS.map((userId, i) => ({ userId, seatNo: i + 1 })),
    stacks,
    pot: 0,
    community: [],
    dealerSeatNo: 1,
    turnUserId: "u2",
    handId,
    handSeed,
    communityDealt: 0,
    toCallByUserId: Object.fromEntries(USERS.map((u) => [u, 0])),
    betThisRoundByUserId: Object.fromEntries(USERS.map((u) => [u, 0])),
    actedThisRoundByUserId: Object.fromEntries(USERS.map((u) => [u, false])),
    foldedByUserId: Object.fromEntries(USERS.map((u) => [u, false])),
    contributionsByUserId: Object.fromEntries(USERS.map((u) => [u, 0])),
    lastAggressorUserId: null,
    lastActionRequestIdByUserId: {},
    turnNo: 1,
    turnStartedAt: now(),
    turnDeadlineAt: now() + 15000,
  };

  const deck = deriveRemainingDeck({
    handSeed,
    seatUserIdsInOrder: USERS,
    communityDealt: 0,
  });

  const dealt = dealHoleCards(deriveDeck(handSeed), USERS);

  const privateState = {
    deck,
    holeCardsByUserId: dealt.holeCardsByUserId,
    handSeed,
  };

  return { state: { ...base, ...privateState }, privateState, initialTotal };
}

/* ------------------------------- main ------------------------------- */

async function main() {
  console.log(
    "[money] POKER_DEAL_SECRET present:",
    Boolean(process.env.POKER_DEAL_SECRET?.trim())
  );

  const HANDS = Number(process.env.MONEY_HANDS || 30);
  const STEPS = Number(process.env.MONEY_STEPS || 300);

  console.log(`[money] hands=${HANDS} steps/hand=${STEPS}`);

  for (let h = 1; h <= HANDS; h++) {
    const { state: initial, privateState, initialTotal } =
      buildInitialState();

    let state = initial;

    assert.equal(
      isStateStorageValid(state, { requirePrivate: true }),
      true,
      "initial state invalid"
    );

    assertMoneyInvariants(state, initialTotal);

    if (h === 1) snapshot("START", state);

    for (let i = 1; i <= STEPS; i++) {
      if (state.phase === "SHOWDOWN" || state.phase === "HAND_DONE") break;

      const userId = state.turnUserId;
      const action = chooseLegalAction(state, userId);

      try {
          state = applyAndAdvance(state, privateState, userId, action);
      } catch (e) {
          if (e?.message === "invalid_action") {
            // benign: turn moved or edge condition
            continue;
          }
          throw e;
      }

      assert.equal(
        isStateStorageValid(state, { requirePrivate: true }),
        true,
        "state invalid (post-step)"
      );

      assertMoneyInvariants(state, initialTotal);

      if (h === 1 && i <= 12) {
        snapshot(`STEP ${i}: ${userId} ${action.type}`, state);
      }
    }
  }

  console.log("\n[money] âœ… completed (money invariants held)");
}

main().catch((e) => {
  console.error("[money] fatal:", e);
  process.exit(1);
});

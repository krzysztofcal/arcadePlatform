#!/usr/bin/env node
/**
 * Poker engine fuzz / pentest runner (Termux-friendly)
 *
 * Goals:
 * - Stress reducer with legal + intentionally illegal actions
 * - Ensure we never clobber state with undefined (common signature mismatch bug)
 * - Validate invariants using isStateStorageValid(requirePrivate)
 * - Print repro seed + last N steps for debugging
 */

import assert from "node:assert/strict";

import { deriveDeck, deriveCommunityCards, deriveRemainingDeck } from "../../netlify/functions/_shared/poker-deal-deterministic.mjs";
import { dealHoleCards } from "../../netlify/functions/_shared/poker-engine.mjs";
import { advanceIfNeeded, applyAction, getLegalActions } from "../../netlify/functions/_shared/poker-reducer.mjs";
import { isStateStorageValid } from "../../netlify/functions/_shared/poker-state-utils.mjs";

// --------------------------- config ---------------------------
const HANDS = Number(process.env.FUZZ_HANDS || 50);
const STEPS_PER_HAND = Number(process.env.FUZZ_STEPS || 200);
const ILLEGAL_PCT = Number(process.env.FUZZ_ILLEGAL_PCT || 20); // % steps intentionally illegal
const HISTORY_KEEP = Number(process.env.FUZZ_HISTORY_KEEP || 30);
const PLAYERS = ["u1", "u2", "u3"];

// You can re-run exactly with: FUZZ_SEED=... node tools/poker/pentest-fuzz.mjs
const SEED = process.env.FUZZ_SEED ? Number(process.env.FUZZ_SEED) : Date.now();

// --------------------------- tiny seeded RNG ---------------------------
function mulberry32(seed) {
  let t = seed >>> 0;
  return function () {
    t += 0x6d2b79f5;
    let x = t;
    x = Math.imul(x ^ (x >>> 15), x | 1);
    x ^= x + Math.imul(x ^ (x >>> 7), x | 61);
    return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
  };
}
const rng = mulberry32(SEED);

function rint(min, max) {
  // inclusive
  const a = Math.ceil(min);
  const b = Math.floor(max);
  return Math.floor(rng() * (b - a + 1)) + a;
}
function rpick(arr) {
  return arr[rint(0, arr.length - 1)];
}
function chance(pct) {
  return rng() * 100 < pct;
}

// --------------------------- helpers ---------------------------
function safeJson(x) {
  try {
    return JSON.stringify(x);
  } catch {
    return String(x);
  }
}

function snapshotState(state) {
  if (!state || typeof state !== "object") {
    return { stateType: typeof state, stateValue: state };
  }
  return {
    phase: state.phase,
    handId: state.handId,
    dealerSeatNo: state.dealerSeatNo,
    turnUserId: state.turnUserId,
    communityDealt: state.communityDealt,
    communityLen: Array.isArray(state.community) ? state.community.length : null,
    pot: state.pot,
    stacks: state.stacks,
    toCallByUserId: state.toCallByUserId,
    betThisRoundByUserId: state.betThisRoundByUserId,
    actedThisRoundByUserId: state.actedThisRoundByUserId,
    foldedByUserId: state.foldedByUserId,
    contributionsByUserId: state.contributionsByUserId,
    lastAggressorUserId: state.lastAggressorUserId ?? null,
    turnNo: state.turnNo,
    seats: Array.isArray(state.seats) ? state.seats.map((s) => ({ userId: s.userId, seatNo: s.seatNo })) : [],
  };
}

function ensureCommunityMatchesDealt(state, seatUserIdsInOrder) {
  // If reducer bumped communityDealt, derive deterministic community
  const dealt = Number.isInteger(state.communityDealt) ? state.communityDealt : 0;
  const curLen = Array.isArray(state.community) ? state.community.length : 0;
  if (dealt > curLen) {
    const comm = deriveCommunityCards({
      handSeed: state.handSeed,
      seatUserIdsInOrder,
      communityDealt: dealt,
    });
    return { ...state, community: comm };
  }
  return state;
}

function unwrapReducerOutput(maybe) {
  // In this repo, applyAction returns the next state directly.
  // But we defensively support { state, events } too.
  if (maybe && typeof maybe === "object" && !Array.isArray(maybe) && maybe.state && typeof maybe.state === "object") {
    return maybe.state;
  }
  return maybe;
}

function normalizeActionForReducer({ userId, type, amount }) {
  const a = { userId, type };
  if (typeof amount === "number") a.amount = amount;
  return a;
}

function chooseLegalAction(state) {
  const turn = state.turnUserId;
  const legalRaw = getLegalActions(state, turn);
  const legal = Array.isArray(legalRaw) ? legalRaw : [];

  // Filter out impossible actions (important for RAISE/BET ranges)
  const filtered = legal.filter((a) => {
    if (!a || typeof a.type !== "string") return false;

    if (a.type === "BET" || a.type === "RAISE") {
      const min = Number.isFinite(a.min) ? a.min : 1;
      const max = Number.isFinite(a.max) ? a.max : 0;
      return max >= min && min >= 1;
    }

    // CALL/CHECK/FOLD are fine if reducer says so
    return true;
  });

  if (filtered.length === 0) {
    // Safe fallback: if nothing is usable, just CHECK (reducer may reject; then it’s a real signal)
    return { userId: turn, type: "CHECK" };
  }

  const pick = rpick(filtered);

  if (pick.type === "BET" || pick.type === "RAISE") {
    const min = Number.isFinite(pick.min) ? pick.min : 1;
    const max = Number.isFinite(pick.max) ? pick.max : min;

    // pick a valid amount within range
    const amount = rint(min, max);
    return { userId: turn, type: pick.type, amount };
  }

  if (pick.type === "CALL") {
    return { userId: turn, type: "CALL" };
  }

  return { userId: turn, type: pick.type };
}

function chooseIllegalAction(state) {
  // Common illegal shapes:
  // - wrong userId (not turn)
  // - invalid type
  // - CHECK when toCall > 0
  // - BET with 0 or negative amount
  // - RAISE without toCall
  const badKind = rint(1, 5);

  if (badKind === 1) {
    const wrongUser = rpick(PLAYERS.filter((u) => u !== state.turnUserId));
    return { userId: wrongUser, type: "CHECK" };
  }
  if (badKind === 2) {
    return { userId: state.turnUserId, type: "HACK" };
  }
  if (badKind === 3) {
    // force CHECK even if toCall > 0 (if toCall is 0 this might become legal; that's fine)
    return { userId: state.turnUserId, type: "CHECK" };
  }
  if (badKind === 4) {
    return { userId: state.turnUserId, type: "BET", amount: 0 };
  }
  // badKind === 5
  return { userId: state.turnUserId, type: "RAISE", amount: 99999999 };
}

function newHandState(handNo) {
  const tableId = "local-fuzz-table";
  const seatUserIdsInOrder = [...PLAYERS];

  const handId = `hand-h${handNo}-${Date.now()}`;
  // keep handSeed stable per hand; use seed + handNo
  const handSeed = `seed-${SEED}-${handNo}`;

  // deterministic private deck/hole cards
  const dealt = dealHoleCards(deriveDeck(handSeed), seatUserIdsInOrder);
  const holeCardsByUserId = dealt.holeCardsByUserId;

  const deck = deriveRemainingDeck({
    handSeed,
    seatUserIdsInOrder,
    communityDealt: 0,
  });

  // IMPORTANT: turnUserId is NOT always u1; in your engine, it depends on dealer.
  // We'll set dealerSeatNo=1, then "first to act preflop" appears to be u2 in your logs.
  // So we set initial turnUserId="u2" to match observed behavior.
  const seats = seatUserIdsInOrder.map((userId, i) => ({ userId, seatNo: i + 1 }));

  const state = {
    tableId,
    phase: "PREFLOP",
    seats,

    // money
    stacks: { u1: 100, u2: 100, u3: 100 },
    pot: 0,

    // dealing state
    community: [],
    communityDealt: 0,

    // turn/dealer
    dealerSeatNo: 1,
    turnUserId: "u2",

    // ids
    handId,
    handSeed,

    // per-round maps
    toCallByUserId: { u1: 0, u2: 0, u3: 0 },
    betThisRoundByUserId: { u1: 0, u2: 0, u3: 0 },
    actedThisRoundByUserId: { u1: false, u2: false, u3: false },
    foldedByUserId: { u1: false, u2: false, u3: false },

    // validity-required
    contributionsByUserId: { u1: 0, u2: 0, u3: 0 },
    lastAggressorUserId: null,
    lastActionRequestIdByUserId: {},
    showdown: null,
    sidePots: null,

    // private
    deck,
    holeCardsByUserId,

    // misc
    turnNo: 1,
  };

  return { state, seatUserIdsInOrder, tableId };
}

// --------------------------- main ---------------------------
async function main() {
  console.log(`[fuzz] hands=${HANDS} steps/hand=${STEPS_PER_HAND} illegal%=${ILLEGAL_PCT}`);
  console.log(`[fuzz] seed=${SEED}`);
  console.log(`[fuzz] POKER_DEAL_SECRET present: ${Boolean(process.env.POKER_DEAL_SECRET && process.env.POKER_DEAL_SECRET.trim())}`);

  if (!process.env.POKER_DEAL_SECRET || !process.env.POKER_DEAL_SECRET.trim()) {
    console.log("[fuzz] WARNING: POKER_DEAL_SECRET missing -> deriveDeck will throw. Export it first.");
    process.exitCode = 2;
    return;
  }

  for (let h = 1; h <= HANDS; h++) {
    const history = [];
    const { state: startState, seatUserIdsInOrder, tableId } = newHandState(h);

    let state = startState;

    // pre-check validity
    assert.equal(
      isStateStorageValid(state, { requirePrivate: true }),
      true,
      "isStateStorageValid(requirePrivate) failed (hand start)"
    );

    for (let step = 1; step <= STEPS_PER_HAND; step++) {
      const makeIllegal = chance(ILLEGAL_PCT);
      const chosen = makeIllegal ? chooseIllegalAction(state) : chooseLegalAction(state);

      const action = normalizeActionForReducer(chosen);

      let ok = true;
      let errMsg = "";
      let before = snapshotState(state);

      try {
        const applied = unwrapReducerOutput(applyAction(state, action));
        if (!applied || typeof applied !== "object") {
          throw new Error("applyAction returned non-object state");
        }
        state = applied;

        // advance, but DO NOT clobber state if it returns nothing
        const maybeAdvanced = unwrapReducerOutput(advanceIfNeeded(state));
        if (maybeAdvanced && typeof maybeAdvanced === "object") {
          state = maybeAdvanced;
        }

        // keep community consistent with communityDealt
        state = ensureCommunityMatchesDealt(state, seatUserIdsInOrder);

        // invariants after a successful apply
        assert.equal(
          isStateStorageValid(state, { requirePrivate: true }),
          true,
          "isStateStorageValid(requirePrivate) failed (post-step)"
        );
      } catch (e) {
        ok = false;
        errMsg = e?.message || String(e);
      }

      const entry = {
        step,
        ok,
        illegal: makeIllegal,
        userId: action.userId,
        action: action.type,
        amount: action.amount,
        phase: before.phase,
        turnUserId: before.turnUserId,
        error: errMsg,
      };
      history.push(entry);
      if (history.length > HISTORY_KEEP) history.shift();

      // If a LEGAL step fails, that's interesting.
      // If an ILLEGAL step fails with "invalid_action", that's expected.
      const expectedIllegalFailure = makeIllegal && (errMsg === "invalid_action" || errMsg.startsWith("invalid_action"));
      if (!ok && !expectedIllegalFailure) {
        console.log("\n[fuzz] ❌ FOUND ISSUE");
        console.log(`hand #${h}`);
        console.log(`error: ${errMsg}`);
        console.log("\nLast state snapshot:");
        console.log(snapshotState(state));
        console.log(`\nRecent history (last ${history.length}):`);
        console.log(history);
        console.log(`\nRepro: FUZZ_SEED=${SEED} FUZZ_HANDS=${HANDS} FUZZ_STEPS=${STEPS_PER_HAND} FUZZ_ILLEGAL_PCT=${ILLEGAL_PCT} node tools/poker/pentest-fuzz.mjs`);
        process.exitCode = 1;
        return;
      }

      // Stop early if we reach terminal phases
      if (state.phase === "SHOWDOWN" || state.phase === "HAND_DONE") {
        break;
      }
    }
  }

  console.log("\n[fuzz] ✅ completed with no unexpected invariant breaks");
}

main().catch((e) => {
  console.error("[fuzz] fatal:", e?.stack || e);
  process.exitCode = 1;
});
